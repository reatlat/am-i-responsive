"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function ($) {

    /**
     * $('#element').donetyping(callback[, timeout=1000])
     *
     * source: http://stackoverflow.com/a/14042239/3705299
     *
     * Fires callback when a user has finished typing. This is determined by the time elapsed
     * @callback: function to be called when even triggers
     * @timeout:  (default=1000) timeout, in ms, to to wait before triggering event if not caused by blur.
     * Requires jQuery 1.7+
     * Tested with jQuery 1.11.3
     * @link https://gist.github.com/reatlat/88aed7c17acaeea99fbd58a5d99cb7e3
     */
    $.fn.extend({

        donetyping: function donetyping(callback, timeout) {

            timeout = timeout || 1e3; // 1 second default timeout

            var timeoutReference,
                doneTyping = function doneTyping(el) {

                if (!timeoutReference) return;
                timeoutReference = null;
                callback.call(el);
            };
            return this.each(function (i, el) {
                var $el = $(el);
                // Chrome Fix (Use keyup over keypress to detect backspace)
                // thank you @palerdot
                $el.is(':input') && $el.on('keyup keypress paste', function (e) {
                    // This catches the backspace button in chrome, but also prevents
                    // the event from triggering too preemptively. Without this line,
                    // using tab/shift+tab will make the focused element fire the callback.
                    if (e.type == 'keyup' && e.keyCode != 8) return;

                    // Check if timeout has been set. If it has, "reset" the clock and
                    // start over again.
                    if (timeoutReference) clearTimeout(timeoutReference);
                    timeoutReference = setTimeout(function () {
                        // if we made it here, our timeout has elapsed. Fire the
                        // callback
                        doneTyping(el);
                    }, timeout);
                }).on('blur', function () {
                    // If we can, fire the event since we're leaving the field
                    doneTyping(el);
                });
            });
        }
    });

    var AMI = function () {
        function AMI(_ref) {
            var _ref$debug = _ref.debug,
                debug = _ref$debug === undefined ? false : _ref$debug;

            _classCallCheck(this, AMI);

            this.debug = debug;
        }

        /**
         * Initial base scripts
         */


        _createClass(AMI, [{
            key: '_init',
            value: function _init() {
                this._debugLog('_init() =>', this);
                this._initTriggers();
                this._initDraggable();
            }

            /**
             * Debug console output, and show hidden params
             *
             * @param args
             */

        }, {
            key: '_debugLog',
            value: function _debugLog() {
                if (this.debug) {
                    var _console;

                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    (_console = console).log.apply(_console, ['ðŸ¦„ AMI:'].concat(args));
                }
            }

            /**
             * Initial triggers
             */

        }, {
            key: '_initTriggers',
            value: function _initTriggers() {
                this._debugLog('_initTriggers()');

                $('#domain').donetyping(function () {
                    window.AMI._debugLog('donetiping');
                    var url = $('#domain').val();
                    if (!url.match(/^[a-zA-Z]+:\/\//)) {
                        url = 'http://' + url;
                        $('#domain').val(url);
                    }
                    $("iframe").attr('src', url);
                }, 1000);
            }
        }, {
            key: '_initDraggable',
            value: function _initDraggable() {
                var a = 3;
                $('.desktop,.laptop,.tablet,.mobile').draggable({
                    start: function start(event, ui) {
                        $(this).css("z-index", a++);
                    }
                });
                $('.display div').click(function () {
                    $(this).addClass('top').removeClass('bottom');
                    $(this).siblings().removeClass('top').addClass('bottom');
                    $(this).css("z-index", a++);
                });
            }

            /**
             * GET requests from links
             *
             * @param {string} param
             * @param {string} url
             * @returns {*}
             */

        }, {
            key: '_GET',
            value: function _GET(param, url) {
                url = url ? url : window.location.href;
                this._debugLog('_GET() => ', param, url);
                var vars = {};
                url.replace(location.hash, '').replace(/[?&]+([^=&]+)=?([^&]*)?/gi, function (m, key, value) {
                    vars[key] = value !== void 0 ? value : '';
                });
                if (param) {
                    if (vars[param]) {
                        return vars[param];
                    } else {
                        return null;
                    }
                }
                return vars;
            }
        }]);

        return AMI;
    }();

    window.AMI = new AMI({
        debug: true
    });

    window.AMI._init();
})(jQuery);
//# sourceMappingURL=scripts.min.js.map